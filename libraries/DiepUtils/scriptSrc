// ==UserScript==
// @name         DiepUtils(30.11.2024)
// @namespace    http://tampermonkey.net/
// @version      2024-11-23
// @description  A library which hooks into diep.io, adding useful functions which you can use to make your own userscript.
// @author       Mi300
// @match        https://diep.io/*
// @match        https://diep-io.rivet.game/*
// @icon         https://upload.wikimedia.org/wikipedia/commons/2/25/Cube_Animation.gif
// @run-at       document-start
// @grant        none
// ==/UserScript==
window.DiepUtils = null;
let awaitGameLoad = setInterval(() =>
{
    'use strict';
    if (typeof extern === "undefined" || typeof input === "undefined")
    {
        return;
    }
    clearInterval(awaitGameLoad);
    const cr = CanvasRenderingContext2D.prototype;
    const mainCanvas = document.getElementById("canvas");
    const ctx = document.getElementById("canvas")
        .getContext("2d");
    let ctxTransform = [1, 0, 0, 1, 0, 0];
    let arcs = [];
    let squares = [];
    let text = [];
    let curFrameEntities = [];
    let entities = [];
    let ownPlayer;
    let minimapX = 0;
    let minimapY = 0;
    let minimapWidth = 0;
    let minimapHeight = 0;
    let worldX = 0;
    let worldY = 0;
    let mouseX = 0;
    let mouseY = 0;
    let keyPressMap = new Map();
    let fov = 0.5;
    let animationSpeed = 1;
    let mouseLock = false;
    let playerScore = 0;
    let playerLevel = 1;
    let playerTank = "Tank";
    let leaderboardEntries = [];
    let leaderboardBars = [];
    let healthBars = [];
    let curHealthBarBase = null;
    let lastArc = {x:0,y:0}
    let teamColor = "";

    function log(text)
    {
        console.log("[DiepUtils]" + text);
    }

    function getConvar(c)
    {
        return extern.get_convar(c);
    }

    function parseDiepHex(v)
    {
        return "#" + v.split("x")[1];
    }

    function parseDiepScore(s)
    {
        let scoreMultiplier = 1;
        if (s[s.length - 1] === "k")
        {
            scoreMultiplier = 1000;
        }
        else if (s[s.length - 1] === "m")
        {
            scoreMultiplier = 1000000;
        }
        else if (!s.includes("."))
        {
            if (isNaN(s))
            {
                return null
            }
            const toInt = parseInt(s, 10);
            if (toInt === NaN)
            {
                return null;
            }
            return toInt;
        }
        else return null;
        const toFloat = parseFloat(s.slice(0, -1));
        if (toFloat === NaN)
        {
            return null;
        }
        return toFloat * scoreMultiplier;
    }
    input.set_convar = new Proxy(input.set_convar,
    {
        apply: function (method, context, args)
        {
            config[args[0]] = args[1];
            return Reflect.apply(method, context, args)
        }
    });

    function getShapePos(vertices)
    {
        let ret = [0, 0];
        for (let i = 0; i < vertices.length; i++)
        {
            ret[0] += vertices[i][0];
            ret[1] += vertices[i][1];
        }
        ret[0] /= vertices.length;
        ret[1] /= vertices.length;
        return ret;
    }

    function computeCoordinates(ax, ay)
    {
        const dX = ax - minimapX;
        const dY = ay - minimapY;
        worldX = (dX / minimapWidth) * Constants.ARENA_WIDTH;
        worldY = (dY / minimapHeight) * Constants.ARENA_HEIGHT;
    }

    function screen_to_world_position(x, y)
    {
        const midX = x - window.innerWidth / 2;
        const midY = y - window.innerHeight / 2;
        const scaledX = (midX) / (fov / 2.8);
        const scaledY = (midY) / (fov / 2.8);
        return [
            worldX + scaledX,
            worldY + scaledY,
        ]
    }

    function screen_to_world_position2(x, y)
    {
        const midX = x - mainCanvas.width / 2;
        const midY = y - mainCanvas.height / 2;
        const scaledX = (midX) / (fov / 2.8);
        const scaledY = (midY) / (fov / 2.8);
        return [
            worldX + scaledX,
            worldY + scaledY,
        ]
    }

    function world_to_screen_position(x, y)
    {
        const deltaX = x - worldX;
        const deltaY = y - worldY;
        const unscaledX = window.innerWidth / 2 + deltaX * (fov / 2.8);
        const unscaledY = window.innerHeight / 2 + deltaY * (fov / 2.8);
        let ret = [
            unscaledX,
            unscaledY,
        ]
        return ret;
    }

    function world_to_screen_position2(x, y)
    {
        const deltaX = x - worldX;
        const deltaY = y - worldY;
        const unscaledX = mainCanvas.width / 2 + deltaX * (fov / 2.8);
        const unscaledY = mainCanvas.height / 2 + deltaY * (fov / 2.8);
        let ret = [
            unscaledX,
            unscaledY,
        ]
        return ret;
    }

    function world_to_minimap_position(x, y)
    {
        return [
            minimapWidth * (x / Constants.ARENA_WIDTH) + minimapX,
            minimapHeight * (y / Constants.ARENA_HEIGHT) + minimapY
        ]
    }

    function getDistance(x1, y1, x2, y2)
    {
        const distX = x1 - x2;
        const distY = y1 - y2;
        return Math.hypot(distX, distY);
    }
    // arr: array of objects with x and y properties
    function getClosestTo(arr, x, y)
    {
        return arr.reduce(function (acc, cur)
        {
            if (!acc) return cur;
            const dist_acc = getDistance(x, y, acc.x, acc.y);
            const dist_cur = getDistance(x, y, cur.x, cur.y);
            return dist_acc > dist_cur ? cur : acc;
        }, null)
    }

    function getClosestTo2(arr, wx, wy)
    {
        return arr.reduce(function (acc, cur)
        {
            if (!acc) return cur;
            const dist_acc = getDistance(wx, wy, acc.wx, acc.wy);
            const dist_cur = getDistance(wx, wy, cur.wx, cur.wy);
            return dist_acc > dist_cur ? cur : acc;
        }, null)
    }
    // arr: takes an input of an array of texts but gets the centre of the image
    function getClosestText(arr, x, y)
    {
        return arr.reduce(function (acc, cur)
        {
            if (!acc) return cur;
            const dist_acc = getDistance(x, y, acc.mx, acc.my);
            const dist_cur = getDistance(x, y, cur.mx, cur.my);
            return dist_acc > dist_cur ? cur : acc;
        }, null)
    }

    function getCurFramePlayers()
    {
      const arr = [...arcs, ...squares]
        for (let a = 0; a < arr.length; ++a)
        {
            const arc = arr[a];
            const rr = (arc.r) / (fov);
            const [wx, wy] = screen_to_world_position2(arc.x, arc.y);
            if (!inBounds(wx, wy))
            {
                continue;
            }
            const scoreText = [
                arc.x,
                arc.y - arc.r * 1.3,
            ]
            const nameText = [
                arc.x,
                arc.y - arc.r * 2,
            ]
            const healthText = [
                arc.x,
                arc.y + arc.r * 1.3,
            ]
            const closestScoreText = getClosestText(text, ...scoreText);
            const closestNameText = getClosestText(text, ...nameText);
            const closestHealthText = getClosestText(text, ...healthText);
            const closestHealthBar = getClosestText(healthBars, ...healthText);
            const distanceToScoreText = closestScoreText ? getDistance(...scoreText, closestScoreText.mx, closestScoreText.my) : Infinity;
            const distanceToNameText = closestNameText ? getDistance(...nameText, closestNameText.mx, closestNameText.my) : Infinity;
            const distanceToHealthText = closestHealthText ? getDistance(...healthText, closestHealthText.mx, closestHealthText.my) : Infinity;
            const distanceToHealthBar = closestHealthBar ? getDistance(...healthText, closestHealthBar.mx, closestHealthBar.my) : Infinity;
            let score = "";
            let name = "";
            let health = "";
            let healthBarGradient = 1;
            let maxHealth = -1;
            if (distanceToScoreText < 25)
            {
                score = parseDiepScore(closestScoreText ? closestScoreText.text : "-1");
            }
            if (distanceToNameText < 25)
            {
                name = closestNameText ? closestNameText.text : "";
            }
            if (distanceToHealthText < 25 && distanceToHealthBar < 25)
            {
                health = parseFloat(closestHealthText ? closestHealthText : "-1");
                healthBarGradient = closestHealthBar ? closestHealthBar.healthBarGradient : 1;

                maxHealth = (1 / healthBarGradient) * health;

            }

              if(rr > 19 && score !== ""){
                let num = curFrameEntities.length;
                curFrameEntities.push(
                {
                    type: "player",
                    color: arc.fs,
                    x: arc.x,
                    y: arc.y,
                    r: arc.r,
                    rr,
                    wx,
                    wy,
                    name,
                    score,
                    health,
                    maxHealth,
                    healthBarGradient,
                    num,
                })
              }
              else if(false && rr < 19 && score === "")
              {
                curFrameEntities.push(
                {
                    type: "bullet",
                    color: arc.fs,
                    x: arc.x,
                    y: arc.y,
                    r: arc.r,
                    rr,
                    wx,
                    wy,
                    name: "bullet",
                })
              }
        }
        const closestArc = getClosestTo(arcs, mainCanvas.width / 2, mainCanvas.height / 2);
        if (closestArc && getDistance(closestArc.x, closestArc.y, mainCanvas.width / 2, mainCanvas.height / 2) < 80)
        {
            if (closestArc.r / fov > 19)
            {
                const [wx, wy] = screen_to_world_position2(closestArc.x, closestArc.y);
                ownPlayer = {
                    x: closestArc.x,
                    y: closestArc.y,
                    wx,
                    wy,
                    color: closestArc.fs,
                }
            }
        }
    }



    function inBounds(wx, wy)
    {
        return wx > -2000 && wx < 28000 && wy > -2000 && wy < 28000;
    }

const sample_size = 7;
    function updateEntities()// EXTREMELY MESSY CODE
    {
        let nextEntities = [];
        for (let i = 0; i < curFrameEntities.length; ++i)
        {
            const closestMatch = getClosestTo2(entities.filter(entity => !(entity.type === "player" && entity.name !== curFrameEntities[i].name)), curFrameEntities[i].wx, curFrameEntities[i].wy);
            if (closestMatch && getDistance(closestMatch.wx, closestMatch.wy, curFrameEntities[i].wx, curFrameEntities[i].wy) < 25)
            {
                  if(curFrameEntities[i].sides === 3 && (closestMatch.name === "crasher" || crasherColor === curFrameEntities[i].color)){
                    curFrameEntities[i].color = closestMatch.color;
                    curFrameEntities[i].name = "crasher";
                  }
                  else if(curFrameEntities[i].sides === 3 && (closestMatch.type === "drone" || droneColors.includes(curFrameEntities[i].color)))
                  {
                    curFrameEntities[i].color = closestMatch.teamColor;
                    curFrameEntities[i].teamColor = closestMatch.teamColor;
                    curFrameEntities[i].type = "drone";
                  }
                curFrameEntities[i].posArray = closestMatch.posArray;
                curFrameEntities[i].posArray.shift();
                curFrameEntities[i].posArray.push([curFrameEntities[i].wx, curFrameEntities[i].wy, Date.now()]);

              if(curFrameEntities[i].type === "player"){
                if(playerColors.includes(curFrameEntities[i].color)){
                  curFrameEntities[i].teamColor = curFrameEntities[i].color;
                }
                else
                {
                  curFrameEntities[i].teamColor = closestMatch.teamColor || null;
                }
              }
                nextEntities.push(curFrameEntities[i]);
            }
            else
            {
              curFrameEntities[i].posArray = Array.from(new Array(sample_size), () => null);
                if (!(curFrameEntities[i].type == "shape" && shapeColorTable[curFrameEntities[i].sides] !== curFrameEntities[i].color))
                {
                  if(curFrameEntities[i].type === "player" && playerColors.includes(curFrameEntities[i].color)){
                    curFrameEntities[i].teamColor = curFrameEntities[i].color;
                  }
                    nextEntities.push(curFrameEntities[i]);
                }
              else if(crasherColor === curFrameEntities[i].color && curFrameEntities[i].sides === 3){
                curFrameEntities[i].name = "crasher";
                nextEntities.push(curFrameEntities[i]);
              }

               else if(curFrameEntities[i].sides === 3 && curFrameEntities[i].type == "shape" && droneColors.includes(curFrameEntities[i].color)){
                curFrameEntities[i].type = "drone";
                curFrameEntities[i].teamColor = curFrameEntities[i].color;
                nextEntities.push(curFrameEntities[i]);
              }
            }
        }
        entities = nextEntities;
    }

    function readLeaderboard()
    {
        let leaderboardIndex = 0;
        leaderboardEntries = [];
        for (var i = 0; i < text.length; ++i)
        {
            if (text[i].text === "Scoreboard")
            {
                leaderboardIndex = i;
                break;
            }
        }
        for (i = leaderboardIndex + 1; i < text.length; ++i)
        {
            if (leaderboardEntries.length === 10)
            {
                break;
            }
            if (text[i].text === " - ")
            {
                leaderboardEntries.push(
                {
                    name: text[i - 1].text,
                    score: parseDiepScore(text[i + 1].text),
                });
            }
            else if (parseDiepScore(text[i].text) && (parseDiepScore(text[i - 1].text) || text[i - 1].text === "Scoreboard"))
            {
                leaderboardEntries.push(
                {
                    name: "",
                    score: text[i].text,
                });
            }
        }
    }

    function forceHealthText()
    {
        if (window.extern.get_convar("ren_raw_health_values") === "false")
        {
            window.extern.set_convar("ren_raw_health_values", true);
            log("Forced raw health values.");
        }
    }

  let forcingU = false;
    function forceU(){
      console.log(canUpgrade())
      if(canUpgrade()){
        forcingU = true;
        extern.onKeyDown(21);
        console.log("w")
      }
      else if(forcingU){
        forcingU = false;
        extern.onKeyUp(21);
      }
    }

    function predictPosition(x, y, xVel, yVel, time){// xVel, yVel units per milisecond, time is miliseconds
      const predictedOffsetX = xVel * time;
      const predictedOffsetY = yVel * time;

      return [predictedOffsetX + x, predictedOffsetY + y]
    }

    function getVel(posArray){
      let velX = 0;
      let velY = 0;
      let instances = 0;

      for(let p = 1; p < posArray.length; ++p){
        if(!posArray[p] || !posArray[p-1]){
          continue;
        }

        instances++;

        const dx = posArray[p][0] - posArray[p-1][0];
        const dy = posArray[p][1] - posArray[p-1][1];
        const dt = posArray[p][2] - posArray[p-1][2];

        if(!dx || !dy){
          continue;
        }

        velX += dx / dt;
        velY += dy / dt;
      }

      if(/*Math.abs(velX) > 1 || Math.abs(velY) > 1 || */[0, Infinity, -Infinity, NaN].includes(velX) || [0, Infinity, -Infinity, NaN].includes(velY)){
        return [0,0];
      }


      return [velX / instances, velY / instances];
    }

  function getTeam(){
     const party_link_button = document.getElementById("copy-party-link");
    if(!party_link_button){
      return;
    }
    switch(party_link_button.className){
    case "active blue":
      teamColor = "#00b2e1";
      break;
    case "active purple":
      teamColor = "#bf7ff5";
      break;
    case "active green":
      teamColor = "#00e16e";
      break;
    case "active red":
      teamColor = "#f14e54";
      break;
  }
  }

  function getUpgrades(){
    let upgrades = 0;
    for(let i = 0; i < buildStatLevels.length; ++i){
      upgrades++;
      if(playerLevel < buildStatLevels[i]){
        break;
      }
    }
    return upgrades;
  }

  function canUpgrade(){
    const rawStats = window.extern.get_convar("game_stats_build");
    return getUpgrades() - 1 > rawStats.length;
  }

  function truncateStats(){
    const rawStats = window.extern.get_convar("game_stats_build");
    return rawStats.slice(0, getUpgrades())
  }

  function getStats(){
    const rawStats = window.extern.get_convar("game_stats_build");
    let stats = {
      healthRegen: 0,
      maxHealth: 0,
      bodyDamage: 0,
      bulletSpeed: 0,
      bulletPenetration: 0,
      bulletDamage: 0,
      reload: 0,
      movementSpeed: 0,
    }
    for(let i = 0; i < rawStats.length; ++i){
      stats[statNumbers[rawStats[i]]]++;
    }
    return stats;
  }

  function getTankBulletSpeedOffset(tank){
    return bulletSpeedOffsets[tank] || 1;
  }



  const bulletSpeedOffsets = {
    "Skimmer": 0.5,
    "Factory": 0.56,
    "Annihilator": 0.7,
    "Streamliner": 1.1,
    "Auto Gunner": 1.1,
    "Gunner": 1.1,
    "Predator": 1.4,
    "Mothership": 0.48,
    "Manager": 0.8,
    "Hybrid": 0.7,
    "Ranger": 1.5,
    "Stalker": 1.5,
    "Assassin": 1.5,
    "Sniper": 1.5,
    "Hunter": 1.4,
    "Necromancer": 0.72,
    "Arena Closer": 2,
    "Overlord": 0.8,
    "Overseer": 0.8,
    "Destroyer": 0.7,
  }







    class Hook
    {
        constructor()
        {
            this.overriddenFuncs = [];
            let that = this;
            const _toString = Function.prototype.toString;
            const toString = function ()
            {
                switch (this)
                {
                case toString:
                {
                    return _toString.call(_toString)
                }
                }
                for (let i = 0; i < that.overriddenFuncs.length; i++)
                {
                    const origional = that.overriddenFuncs[i][0];
                    const modified = that.overriddenFuncs[i][1];
                    if (this == modified)
                    {
                        return _toString.call(origional);
                    }
                }
                return _toString.call(this);
            };
            Function.prototype.toString = toString;
        }
        addHook(obj, func, callee, function_end = function (_this, args) {})
        {
            const origional = obj[func];
            const modified = new Proxy(obj[func],
            {
                apply: function (method, context, args)
                {
                    const modified = callee(context, args);
                    if (!modified)
                    {
                        return function_end(this, args);
                    }
                    context = modified[0];
                    args = modified[1];
                    try
                    {
                        return Reflect.apply(method, context, args);
                    }
                    finally
                    {
                        function_end(this, args);
                    }
                }
            });
            this.overriddenFuncs.push([origional, modified]);
            obj[func] = modified;
        }
        freeze()
        {
            Object.freeze(CanvasRenderingContext2D.prototype);
            Object.freeze(Function.prototype);
        }
    }
    const hook = new Hook();
    const config = {
        grid_base_alpha: 0.05,
        ren_raw_health_values: false,
    }
    const Constants = {
        ARENA_WIDTH: 26000,
        ARENA_HEIGHT: 26000,
    }
    const upgrades = [
    {
        hex: "#8efffb",
        num: 0,
        posX: 0,
        posY: 0,
    },
    {
        hex: "#b4ff8e",
        num: 1,
        posX: 1,
        posY: 0,
    },
    {
        hex: "#ff8e8e",
        num: 2,
        posX: 0,
        posY: 1,
    },
    {
        hex: "#ffeb8e",
        num: 3,
        posX: 1,
        posY: 1,
    },
    {
        hex: "#8eb2ff",
        num: 4,
        posX: 0,
        posY: 2,
    },
    {
        hex: "#b58eff",
        num: 5,
        posX: 1,
        posY: 2,
    }, ]
    const upgradeColors = ["#8efffb", "#b4ff8e", "#ff8e8e", "#ffeb8e", "#8eb2ff", "#b58eff"];
    const upgradeColorTable = {
        "#8efffb": upgrades[0],
        "#b4ff8e": upgrades[1],
        "#ff8e8e": upgrades[2],
        "#ffeb8e": upgrades[3],
        "#8eb2ff": upgrades[4],
        "#b58eff": upgrades[5],
    }
    const upgradePositionTable = new Array(6);
    const shapeNameTable = {
        3: "Triangle",
        4: "Square",
        5: "Pentagon",
    }
    const shapeColorTable = {
        3: "#fc7677",
        4: "#ffe869",
        5: "#768dfc"
    }
    const crasherColor = "#f177dd";
    const droneColors = [
      "#f14e54",
      "#00b2e1",
      "#00e16e",
      "#bf7ff5",
    ]
    const playerColors = [
      "#f14e54",
      "#00b2e1",
      "#00e16e",
      "#bf7ff5",
    ]
    const leaderboardColours = [
        "#f14e54",
        "#00b2e1",
        "#00e16e",
        "#bf7ff5",
        "#43ff91",
    ]
    const keyCodeTable = {
    "KeyA" : 1,
    "KeyB" : 2,
    "KeyC" : 3,
    "KeyD" : 4,
    "KeyE" : 5,
    "KeyF" : 6,
    "KeyG" : 7,
    "KeyH" : 8,
    "KeyI" : 9,
    "KeyJ" : 10,
    "KeyK" : 11,
    "KeyL" : 12,
    "KeyM" : 13,
    "KeyN" : 14,
    "KeyO" : 15,
    "KeyP" : 16,
    "KeyQ" : 17,
    "KeyR" : 18,
    "KeyS" : 19,
    "KeyT" : 20,
    "KeyU" : 21,
    "KeyV" : 22,
    "KeyW" : 23,
    "KeyX" : 24,
    "KeyY" : 25,
    "KeyZ" : 26,
    "ArrowUp" : 27,
    "ArrowLeft" : 28,
    "ArrowDown" : 29,
    "ArrowRight" : 30,
    "Tab" : 31,
    "Enter" : 32,
    "NumpadEnter" : 33,
    "ShiftLeft" : 34,
    "ShiftRight" : 35,
    "Space" : 36,
    "Numpad0" : 37,
    "Numpad1" : 38,
    "Numpad2" : 39,
    "Numpad3" : 40,
    "Numpad4" : 41,
    "Numpad5" : 42,
    "Numpad6" : 43,
    "Numpad7" : 44,
    "Numpad8" : 45,
    "Numpad9" : 46,
    "Digit0" : 47,
    "Digit1" : 48,
    "Digit2" : 49,
    "Digit3" : 50,
    "Digit4" : 51,
    "Digit5" : 52,
    "Digit6" : 53,
    "Digit7" : 54,
    "Digit8" : 55,
    "Digit9" : 56,
    "F2" : 57,
    "End" : 58,
    "Home" : 59,
    "Semicolon" : 60,
    "Comma" : 61,
    "NumpadComma" : 62,
    "Period" : 63,
    "Backslash" : 64,
    }
    const keyTable = {
    "a" : 1,
    "b" : 2,
    "c" : 3,
    "d" : 4,
    "e" : 5,
    "f" : 6,
    "g" : 7,
    "h" : 8,
    "i" : 9,
    "j" : 10,
    "k" : 11,
    "l" : 12,
    "m" : 13,
    "n" : 14,
    "o" : 15,
    "p" : 16,
    "q" : 17,
    "r" : 18,
    "s" : 19,
    "t" : 20,
    "u" : 21,
    "v" : 22,
    "w" : 23,
    "x" : 24,
    "y" : 25,
    "z" : 26,
    "ArrowUp" : 27,
    "ArrowLeft" : 28,
    "ArrowDown" : 29,
    "ArrowRight" : 30,
    "Tab" : 31,
    "Enter" : 32,
    "NumpadEnter" : 33,
    "Shift" : 34,
    " " : 36,
    "0" : 47,
    "1" : 48,
    "2" : 49,
    "3" : 50,
    "4" : 51,
    "5" : 52,
    "6" : 53,
    "7" : 54,
    "8" : 55,
    "9" : 56,
    "F2" : 57,
    "End" : 58,
    "Home" : 59,
    ";" : 60,
    "," : 61,
    "." : 63,
    "Backslash" : 64,
    }
    const buildKeyMap = [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "0",
        "u",
        "m",
    ]
    const buildStatLevels = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30, 33, 36, 39, 42, 45];
const statNumbers = {
    1: "healthRegen",
    2: "maxHealth",
    3: "bodyDamage",
    4: "bulletSpeed",
    5: "bulletPenetration",
    6: "bulletDamage",
    7: "reload",
    8: "movementSpeed"
  }







    hook.addHook(cr, "arc", function (_this, args)
    {
        const t = _this.getTransform();
        if (lastArc.x === t.e + args[0] && lastArc.y === t.f + args[1]){
          arcs.push(
          {
            x: t.e + args[0],
            y: t.f + args[1],
            r: lastArc.r,
            fs: _this.fillStyle,
            ss: _this.strokeStyle
          });
        }
      else{
        lastArc = {
            x: t.e + args[0],
            y: t.f + args[1],
            r: Math.hypot(t.b, t.a),
            fs: _this.fillStyle,
            ss: _this.strokeStyle
          }
      }
        
        return [_this, args];
    });
    hook.addHook(cr, "setTransform", function (_this, args)
    {
        ctxTransform = args;
        return [_this, args];
    });
    hook.addHook(cr, "drawImage", function (_this, args)
    {
        if (args[0].renderMethod)
        {

            const x = ctxTransform[4] + args[1];
            const y = ctxTransform[5] + args[2];
            if (args[0].renderMethod.method === "strokeText")
            {

                text.push(
                {
                    x,
                    y,
                    cw: args[0].width,
                    ch: args[0].height,
                    mx: x + args[0].width / 4,
                    my: y + args[0].height / 4,
                    text: args[0].renderMethod.text,
                });
                const imageText = args[0].renderMethod.text;
                if (imageText.startsWith("Score: "))
                {
                    playerScore = Number(imageText.slice(7)
                        .replace(",", ""));
                }
                else if (imageText.startsWith("Lvl "))
                {
                    if (imageText[5] == " ")
                    {
                        playerLevel = Number(imageText.slice(4, 5));
                        playerTank = imageText.slice(6);
                    }
                    else if (imageText[5] != " ")
                    {
                        playerLevel = Number(imageText.slice(4, 6));
                        playerTank = imageText.slice(7);
                    }
                }
                if (!isNaN(imageText) && imageText.includes("."))
                { //health text
                    const closestHealthBar = getClosestText(healthBars, x + args[0].width / 4, y + args[0].height / 4);
                    if (closestHealthBar && getDistance(closestHealthBar.mx, closestHealthBar.my, x + args[0].width / 4, y + args[0].height / 4) < 5)
                    {
                        return;
                    }
                }
            }
            if (args[0].renderMethod.method === "fillRect")
            {

                if (args[0].isUpgradeButton)
                {
                    upgradePositionTable[args[0].upgradeButton.num] = [x + args[0].width / 4, y + args[0].height / 4];
                }


            }
        }
        return [_this, args];
    });
    hook.addHook(cr, "strokeText", function (_this, args)
    {
        if (_this.canvas.id !== "canvas")
        {
            _this.canvas.renderMethod = {
                method: "strokeText",
                text: args[0],
                args,
                fillStyle: _this.fillStyle,
            };
        }
        return [_this, args];
    });
    hook.addHook(cr, "fillRect", function (_this, args)
    {
        if (_this.canvas.id !== "canvas")
        {
            if (upgradeColors.includes(_this.fillStyle))
            {
                _this.canvas.isUpgradeButton = true;
                _this.canvas.upgradeButton = upgradeColorTable[_this.fillStyle];

            }


            _this.canvas.renderMethod = {
                method: "fillRect",
                args,
                fillStyle: _this.fillStyle,
                strokeStyle: _this.strokeStyle,
            };
        }

        return [_this, args];
    });
    hook.addHook(cr, "strokeRect", function (_this, args)
    {
        if (ctxTransform[4] !== 0 && ctxTransform[5] !== 0)
        {
            minimapX = ctxTransform[4];
            minimapY = ctxTransform[5];
            minimapWidth = ctxTransform[0];
            minimapHeight = ctxTransform[3];
        }
        return [_this, args];
    });
    hook.addHook(cr, "stroke", function (_this, args)
    {
        if (["#cccccc", "#cdcdcd"].includes(_this.fillStyle) && _this.strokeStyle == '#000000')
        {
            fov = (_this.globalAlpha / config.grid_base_alpha);
        }
        if (vertexRenderingStack.length === 2)
        {
            if (leaderboardColours.includes(_this.strokeStyle))
            {
                leaderboardBars.push(
                {
                    x: vertexRenderingStack[0][0],
                    y: vertexRenderingStack[0][1],
                    w: vertexRenderingStack[1][0] - vertexRenderingStack[0][0],
                });
            }
            if (_this.strokeStyle === "#555555")
            {
                curHealthBarBase = {
                    x: vertexRenderingStack[0][0],
                    y: vertexRenderingStack[0][1],
                    w: vertexRenderingStack[1][0] - vertexRenderingStack[0][0],
                }
            }
            else
            {
                if (_this.strokeStyle === "#85e37d" && curHealthBarBase &&
                    curHealthBarBase.x == vertexRenderingStack[0][0] &&
                    curHealthBarBase.y == vertexRenderingStack[0][1])
                {
                    healthBars.push(
                    {
                        x: vertexRenderingStack[0][0],
                        y: vertexRenderingStack[0][1],
                        mx: vertexRenderingStack[0][0] + curHealthBarBase.w / 2,
                        my: vertexRenderingStack[0][1],
                        w: vertexRenderingStack[1][0] - vertexRenderingStack[0][0],
                        mw: curHealthBarBase.w,
                        healthBarGradient: (vertexRenderingStack[1][0] - vertexRenderingStack[0][0]) / (curHealthBarBase.w)
                    });
                }
                curHealthBarBase = null;
            }
        }
        return [_this, args];
    });
    let vertexRenderingStack = new Array();
    let shapeRenderPart = -1;
    hook.addHook(cr, "beginPath", function (_this, args)
    {
        shapeRenderPart = 0;
        vertexRenderingStack = new Array();
        return [_this, args];
    });
    hook.addHook(cr, "moveTo", function (_this, args)
    {
        shapeRenderPart++;
        vertexRenderingStack.push(args);
        return [_this, args];
    });
    hook.addHook(cr, "lineTo", function (_this, args)
    {
        shapeRenderPart++;
        vertexRenderingStack.push(args);
        return [_this, args];
    });
    hook.addHook(cr, "fill", function (_this, args)
    {
        const [x, y] = getShapePos(vertexRenderingStack);
        if (_this.fillStyle == "#000000" && _this.globalAlpha > 0.949 && shapeRenderPart == 3)
        {
            computeCoordinates(x, y);
            return [_this, args];
        }
        if(["#999999", "#000000"].includes(_this.fillStyle)){
          return [_this, args];
        }
        const [wx, wy] = screen_to_world_position2(x, y);
        if ([3, 4, 5].includes(shapeRenderPart) && _this.canvas.id === mainCanvas.id)
        {

          if(shapeRenderPart === 4 && shapeColorTable[4] !== _this.fillStyle){
            const r = getDistance(x, y, vertexRenderingStack[0][0], vertexRenderingStack[0][1])
            squares.push(
            {
                x,
                y,
                r,
                fs: _this.fillStyle,
                ss: _this.strokeStyle
            });
          }
          if(!(shapeRenderPart === 4 && playerColors.includes(_this.fillStyle))){
            curFrameEntities.push(
            {
                type: "shape",
                x,
                y,
                wx,
                wy,
                sides: shapeRenderPart,
                name: shapeNameTable[shapeRenderPart],
                color: _this.fillStyle,
            });
          }
        }
        return [_this, args];
    });
    const mouseHook = {
        apply: function (method, context, args)
        {
            if (args[3]) return Reflect.apply(method, context, args);
            [mouseX, mouseY] = [args[1], args[2]];
            if (!mouseLock) return Reflect.apply(method, context, args);
        }
    }
    extern.onTouchStart = new Proxy(extern.onTouchStart, mouseHook);
    extern.onTouchMove = new Proxy(extern.onTouchMove, mouseHook);
    extern.onTouchEnd = new Proxy(extern.onTouchEnd, mouseHook);
    performance._now = performance.now
    performance.now = function ()
    {
        return performance._now() * animationSpeed;
    }

    function onFrame()
    {
        window.requestAnimationFrame(onFrame);
        getTeam();
        getCurFramePlayers();
        updateEntities();
        readLeaderboard();
        dieputils.gameManager.frameStartFuncs.forEach(func => func());
        dieputils.gameManager.frameEndFuncs.forEach(func => func());
        forceHealthText();
        forceU();
        curFrameEntities = [];
        leaderboardBars = [];
        healthBars = [];
        arcs = [];
        squares = [];
        text = [];
    }

    function init()
    {
        hook.freeze();
        window.requestAnimationFrame(onFrame);
    }
    class EntityManager
    {
        getEntities()
        {
            return entities;
        }
        getPlayers()
        {
            return entities.filter(entity => entity.type === "player");
        }
        getDrones()
        {
            return entities.filter(entity => entity.type === "drone");
        }
        getBullets(){
          return entities.filter(entity => entity.type === "bullet");
        }
        getShapes()
        {
            return entities.filter(entity => entity.type === "shape");
        }
        getTriangles()
        {
            return entities.filter(entity => entity.type === "shape" && entity.name === "Triangle");
        }
        getSquares()
        {
            return entities.filter(entity => entity.type === "shape" && entity.name === "Square");
        }
        getPentagons()
        {
            return entities.filter(entity => entity.type === "shape" && entity.name === "Pentagon");
        }
        getCrashers(){
          return entities.filter(entity => entity.type === "shape" && entity.name === "crasher");
        }
        getPlayer()
        {
            return ownPlayer;
        }
        getClosestEntity(type = null, shouldBeEnemy = false, name = null)
        {
            return entities.filter(entity => (!shouldBeEnemy || entity.teamColor !== teamColor) && (type === null || type === entity.type) && (name === null || name === entity.name))
                .reduce(function (acc, cur)
                {
                    if (!acc) return cur;
                    const dist_acc = getDistance(mainCanvas.width/2, mainCanvas.height/2, acc.x, acc.y);
                    const dist_cur = getDistance(mainCanvas.width/2, mainCanvas.height/2, cur.x, cur.y);
                    return dist_acc > dist_cur ? cur : acc;
                }, null)
        }
    }
    class GameManager
    {
        constructor()
        {
            this.frameStartFuncs = [];
            this.frameEndFuncs = [];
        }
        onFrameStart(consumer)
        {
            this.frameStartFuncs.push(consumer);
        }
        onFrameEnd(consumer)
        {
            this.frameEndFuncs.push(consumer);
        }
        setAnimationSpeed(s)
        {
            animationSpeed = s;
        }
        getGamemode()
        {
            return window.__common__.active_gamemode;
        }
        getRegion()
        {
            return window.__common__.active_region;
        }
        hasAvailableDoms()
        {
            return window.__common__.has_available_doms;
        }
        getKillerName()
        {
            return window.__common__.killer_name;
        }
        getTank()
        {
            return playerTank;
        }
        getScore()
        {
            return playerScore;
        }
        getLevel()
        {
            return playerLevel;
        }
        getStatsBuild(){
          return getStats();
        }

        notification(text, color = "000000", duration = 3000){
          extern.inGameNotification(text, color, duration);
        }
    }
    class Controller
    {
        setMousePos(x, y)
        {
            [mouseX, mouseY] = [x * (window.innerWidth / mainCanvas.width), y * (window.innerHeight / mainCanvas.height)];
            extern.onTouchMove(-1, mouseX, mouseY, 1);
        }
        getMousePos()
        {
            return [mouseX, mouseY];
        }
        clickMouse(){
          extern.onTouchStart(-1, mouseX, mouseY, 1);
          extern.onTouchMove(-1, mouseX, mouseY, 1);
          extern.onTouchEnd(-1, mouseX, mouseY, 1);
        }
        clickAtPos(x, y){
          const scaled = [x * (window.innerWidth / mainCanvas.width), y * (window.innerHeight / mainCanvas.height)];
          extern.onTouchStart(-1, ...scaled, 1);
          extern.onTouchMove(-1, ...scaled, 1);
          extern.onTouchEnd(-1, ...scaled, 1);

          setTimeout(function(){
            extern.onTouchMove(-1, mouseX, mouseY, 1);
          }, 60);
        }
        holdKey(key)
        {
            extern.onKeyDown(keyTable[key]);
        }
        releaseKey(key)
        {
            extern.onKeyUp(keyTable[key]);
        }
        pressKey(key)
        {
            extern.onKeyDown(keyTable[key]);
            extern.onKeyUp(keyTable[key]);
        }
        switchTank()
        {
            extern.onKeyDown(keyCodeTable["Backslash"]);
            extern.onKeyUp(keyCodeTable["Backslash"]);
        }
        upgradeTank(u)
        {
            const [x, y] = upgradePositionTable[u];
            const [lx, ly] = [mouseX, mouseY];
            mouseLock = true;
            window.extern.onKeyDown(keyTable["c"]);
            window.extern.onKeyUp(keyTable["c"]);
            window.extern.onTouchStart(-1, x, y, 1);
            window.extern.onTouchMove(-1, x, y, 1);
            setTimeout(function ()
            {
                window.extern.onTouchEnd(-1, x, y, 1);
            }, 25);
            setTimeout(function ()
            {
                mouseLock = false;
                window.extern.onKeyDown(keyTable["c"]);
                window.extern.onKeyUp(keyTable["c"]);
                window.extern.onTouchMove(-1, lx, ly, 1);
            }, 35);
        }
    }
    class LeaderboardReader
    {
        getLeaderboardEntries()
        {
            return leaderboardEntries;
        }
        getLeader()
        {
            if (leaderboardEntries.length === 0)
            {
                return null
            }
            return leaderboardEntries[0];
        }
    }
    class Core{
      predictEntityPosition(entity, time){
        const [velX, velY] = getVel(entity.posArray);
        const pred = world_to_screen_position2(...predictPosition(entity.wx, entity.wy, velX, velY, time));

        return pred;
      }

      calculateBulletSpeed(){
        let speedstat = 0;
        const stats = window.extern.get_convar("game_stats_build");
        for(let i = 0; i < stats.length; ++i){
          if(~~stats[i] === 4){
            speedstat++;
          }
        }
        return (20 + speedstat * 3 * getTankBulletSpeedOffset(playerTank)) / 50;
      }
      getDistance(x1, y1, x2, y2){
        return getDistance(x1, y1, x2, y2);
      }
    }
    class DiepUtil
    {
        constructor()
        {
            this.entityManager = new EntityManager();
            this.gameManager = new GameManager();
            this.controller = new Controller();
            this.leaderboardReader = new LeaderboardReader();
            this.core = new Core();
        }
    }
    const dieputils = window.DiepUtils = new DiepUtil();
    init();
}, 400);
